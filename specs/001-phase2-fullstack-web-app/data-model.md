# Data Model: Phase II Full-Stack Web Application

**Feature**: `001-phase2-fullstack-web-app` | **Date**: 2025-12-30 | **Phase**: 1 - Design
**Related**: [spec.md](./spec.md) | [plan.md](./plan.md) | [research.md](./research.md)

## Overview

This document defines the complete data model for the Phase II full-stack todo application, including database schema, SQLModel ORM models, and TypeScript interface definitions for type-safe communication across the stack.

## Database Schema (PostgreSQL)

### Users Table

Managed by Better Auth, stores user authentication and profile information.

```sql
CREATE TABLE users (
    id TEXT PRIMARY KEY,                    -- Better Auth UUID (as text)
    email TEXT UNIQUE NOT NULL,             -- User login email
    name TEXT,                              -- Optional display name
    password_hash TEXT NOT NULL,            -- Bcrypt hash (managed by Better Auth)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes
CREATE UNIQUE INDEX idx_users_email ON users(email);  -- For login lookups
```

**Constraints**:
- `id`: UUID generated by Better Auth, stored as TEXT
- `email`: Must be unique (enforced by Better Auth and database)
- `password_hash`: Never exposed in API responses
- `name`: Optional, can be NULL

### Tasks Table

Core application entity for todo items, with one-to-many relationship to users.

```sql
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,                              -- Auto-increment task ID
    user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(200) NOT NULL,                        -- Task title (1-200 chars)
    description TEXT,                                   -- Optional description
    completed BOOLEAN DEFAULT FALSE,                    -- Completion status
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,     -- Creation timestamp
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP      -- Last modified timestamp
);

-- Indexes (CRITICAL for performance)
CREATE INDEX idx_tasks_user_id ON tasks(user_id);                   -- User isolation queries
CREATE INDEX idx_tasks_user_completed ON tasks(user_id, completed); -- Filtered queries
CREATE INDEX idx_tasks_created_at ON tasks(created_at DESC);        -- Sorting by date
```

**Constraints**:
- `user_id`: Foreign key to users(id) with CASCADE DELETE (when user deleted, all tasks deleted)
- `title`: NOT NULL, VARCHAR(200) enforces max length
- `completed`: Defaults to FALSE (pending status)
- Indexes optimize frequent queries: user filtering, completion filtering, date sorting

### Relationships

```
┌─────────────┐         ┌─────────────┐
│   users     │         │   tasks     │
│─────────────│         │─────────────│
│ id (PK)     │◄───────│ id (PK)     │
│ email       │  1:N   │ user_id (FK)│
│ name        │         │ title       │
│ ...         │         │ description │
└─────────────┘         │ completed   │
                        │ ...         │
                        └─────────────┘
```

- **One-to-Many**: One user has many tasks
- **Cascade Delete**: Deleting user deletes all their tasks
- **Isolation**: Tasks always queried with `WHERE user_id = ?`

## SQLModel ORM Models (Backend)

Location: `backend/app/models/`

### User Model

**File**: `backend/app/models/user.py`

```python
from sqlmodel import SQLModel, Field
from typing import Optional
from datetime import datetime

class User(SQLModel, table=True):
    """User model managed by Better Auth.

    This model represents authenticated users in the system.
    Better Auth handles creation, password hashing, and validation.
    """
    __tablename__ = "users"

    id: str = Field(primary_key=True)  # Better Auth UUID as string
    email: str = Field(unique=True, index=True, max_length=255)
    name: Optional[str] = Field(default=None, max_length=100)
    password_hash: str = Field(exclude=True)  # Never serialized
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    class Config:
        """Pydantic config for SQLModel."""
        json_schema_extra = {
            "example": {
                "id": "550e8400-e29b-41d4-a716-446655440000",
                "email": "user@example.com",
                "name": "John Doe",
                "created_at": "2025-12-30T10:00:00Z",
                "updated_at": "2025-12-30T10:00:00Z"
            }
        }
```

### Task Model

**File**: `backend/app/models/task.py`

```python
from sqlmodel import SQLModel, Field
from typing import Optional
from datetime import datetime

class Task(SQLModel, table=True):
    """Task model for todo items.

    Each task belongs to exactly one user (user_id foreign key).
    All queries MUST filter by user_id to ensure data isolation.
    """
    __tablename__ = "tasks"

    id: Optional[int] = Field(default=None, primary_key=True)  # Auto-increment
    user_id: str = Field(foreign_key="users.id", index=True)   # FK to users
    title: str = Field(min_length=1, max_length=200)           # Required, 1-200 chars
    description: Optional[str] = Field(default=None)           # Optional text
    completed: bool = Field(default=False)                     # Default pending
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    class Config:
        """Pydantic config for SQLModel."""
        json_schema_extra = {
            "example": {
                "id": 1,
                "user_id": "550e8400-e29b-41d4-a716-446655440000",
                "title": "Buy groceries",
                "description": "Milk, eggs, bread",
                "completed": False,
                "created_at": "2025-12-30T10:00:00Z",
                "updated_at": "2025-12-30T10:00:00Z"
            }
        }
```

## Pydantic Schemas (Backend API Contracts)

Location: `backend/app/schemas/`

### Authentication Schemas

**File**: `backend/app/schemas/auth.py`

```python
from pydantic import BaseModel, EmailStr, Field
from typing import Optional

class SignupRequest(BaseModel):
    """User registration request."""
    email: EmailStr = Field(..., description="Valid email address")
    password: str = Field(..., min_length=8, description="Password (min 8 chars)")
    name: Optional[str] = Field(None, max_length=100, description="Display name")

    class Config:
        json_schema_extra = {
            "example": {
                "email": "user@example.com",
                "password": "SecurePass123!",
                "name": "John Doe"
            }
        }

class LoginRequest(BaseModel):
    """User login request."""
    email: EmailStr = Field(..., description="Registered email")
    password: str = Field(..., description="User password")
    remember_me: bool = Field(default=False, description="Remember session")

    class Config:
        json_schema_extra = {
            "example": {
                "email": "user@example.com",
                "password": "SecurePass123!",
                "remember_me": True
            }
        }

class AuthResponse(BaseModel):
    """Authentication response with JWT token."""
    access_token: str = Field(..., description="JWT access token")
    refresh_token: str = Field(..., description="JWT refresh token")
    token_type: str = Field(default="bearer", description="Token type")
    user: dict = Field(..., description="User profile data")

    class Config:
        json_schema_extra = {
            "example": {
                "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
                "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
                "token_type": "bearer",
                "user": {
                    "id": "550e8400-e29b-41d4-a716-446655440000",
                    "email": "user@example.com",
                    "name": "John Doe"
                }
            }
        }

class UserResponse(BaseModel):
    """User profile response (excludes sensitive data)."""
    id: str
    email: str
    name: Optional[str]
    created_at: str  # ISO 8601 format

    class Config:
        json_schema_extra = {
            "example": {
                "id": "550e8400-e29b-41d4-a716-446655440000",
                "email": "user@example.com",
                "name": "John Doe",
                "created_at": "2025-12-30T10:00:00Z"
            }
        }
```

### Task Schemas

**File**: `backend/app/schemas/task.py`

```python
from pydantic import BaseModel, Field
from typing import Optional
from datetime import datetime

class TaskCreate(BaseModel):
    """Request schema for creating a new task."""
    title: str = Field(..., min_length=1, max_length=200, description="Task title")
    description: Optional[str] = Field(None, description="Task description")

    class Config:
        json_schema_extra = {
            "example": {
                "title": "Buy groceries",
                "description": "Milk, eggs, bread"
            }
        }

class TaskUpdate(BaseModel):
    """Request schema for updating an existing task."""
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = Field(None)
    completed: Optional[bool] = Field(None)

    class Config:
        json_schema_extra = {
            "example": {
                "title": "Buy groceries and fruits",
                "description": "Milk, eggs, bread, apples",
                "completed": False
            }
        }

class TaskResponse(BaseModel):
    """Response schema for task data."""
    id: int
    user_id: str
    title: str
    description: Optional[str]
    completed: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        json_schema_extra = {
            "example": {
                "id": 1,
                "user_id": "550e8400-e29b-41d4-a716-446655440000",
                "title": "Buy groceries",
                "description": "Milk, eggs, bread",
                "completed": False,
                "created_at": "2025-12-30T10:00:00Z",
                "updated_at": "2025-12-30T10:00:00Z"
            }
        }

class TaskListResponse(BaseModel):
    """Response schema for task list with metadata."""
    tasks: list[TaskResponse]
    total: int
    completed: int
    pending: int

    class Config:
        json_schema_extra = {
            "example": {
                "tasks": [
                    {
                        "id": 1,
                        "user_id": "550e8400-e29b-41d4-a716-446655440000",
                        "title": "Buy groceries",
                        "description": "Milk, eggs, bread",
                        "completed": False,
                        "created_at": "2025-12-30T10:00:00Z",
                        "updated_at": "2025-12-30T10:00:00Z"
                    }
                ],
                "total": 5,
                "completed": 2,
                "pending": 3
            }
        }
```

## TypeScript Interfaces (Frontend)

Location: `frontend/lib/types.ts`

```typescript
/**
 * Type definitions for Phase II Full-Stack Todo Application
 * Matches backend Pydantic schemas for type-safe API communication
 */

// ============================================================================
// User Types
// ============================================================================

export interface User {
  id: string;
  email: string;
  name: string | null;
  created_at: string;  // ISO 8601 datetime
}

export interface SignupRequest {
  email: string;
  password: string;
  name?: string;
}

export interface LoginRequest {
  email: string;
  password: string;
  remember_me?: boolean;
}

export interface AuthResponse {
  access_token: string;
  refresh_token: string;
  token_type: string;
  user: User;
}

// ============================================================================
// Task Types
// ============================================================================

export interface Task {
  id: number;
  user_id: string;
  title: string;
  description: string | null;
  completed: boolean;
  created_at: string;  // ISO 8601 datetime
  updated_at: string;  // ISO 8601 datetime
}

export interface TaskCreate {
  title: string;
  description?: string;
}

export interface TaskUpdate {
  title?: string;
  description?: string;
  completed?: boolean;
}

export interface TaskListResponse {
  tasks: Task[];
  total: number;
  completed: number;
  pending: number;
}

// ============================================================================
// Filter Types
// ============================================================================

export type TaskFilter = 'all' | 'pending' | 'completed';

export interface TaskQueryParams {
  filter?: TaskFilter;
  sort?: 'created_at' | 'updated_at' | 'title';
  order?: 'asc' | 'desc';
}

// ============================================================================
// API Error Types
// ============================================================================

export interface APIError {
  detail: string | Array<{
    field: string;
    message: string;
  }>;
}

export interface ValidationError {
  field: string;
  message: string;
}
```

## Data Validation Rules

### Backend Validation (Pydantic)

- **Email**: Valid email format (RFC 5322), unique across users
- **Password**: Minimum 8 characters (enforced by Pydantic, hashed by Better Auth)
- **Task Title**: 1-200 characters, required
- **Task Description**: Optional, no max length
- **User ID**: Valid UUID format (enforced by Better Auth)
- **Completed**: Boolean only (true/false)

### Frontend Validation (React Hook Form + Zod)

- **Pre-submit validation**: Check required fields, format, length before API call
- **Real-time feedback**: Show inline errors as user types
- **Match backend rules**: Same constraints as Pydantic schemas

## Database Indexing Strategy

### Critical Indexes (Performance)

1. **`idx_tasks_user_id`**: Every task query filters by user_id (user isolation)
2. **`idx_tasks_user_completed`**: Composite index for filtering completed/pending tasks per user
3. **`idx_tasks_created_at`**: Sorting tasks by creation date (newest first default)
4. **`idx_users_email`**: Login queries by email (unique constraint also creates index)

### Query Optimization

- **List all user tasks**: Uses `idx_tasks_user_id` → O(log n) lookup
- **Filter by completion status**: Uses `idx_tasks_user_completed` → O(log n) lookup
- **Sort by date**: Uses `idx_tasks_created_at` → O(log n) sort
- **Avoid full table scans**: All queries hit an index

## Data Migration Strategy

### Initial Schema Creation

```python
# In backend/app/main.py startup event
from app.database import engine
from app.models import User, Task

@app.on_event("startup")
def create_db_and_tables():
    """Create all tables on application startup."""
    SQLModel.metadata.create_all(engine)
```

**Phase II Approach**:
- Use `create_all()` for initial schema setup (no Alembic migrations needed)
- Schema is stable enough for hackathon timeline
- Future: Add Alembic migrations for Phase III schema changes

### Data Seeding (Development)

Optional seed script for testing: `backend/app/seed.py`

```python
from app.database import get_session
from app.models import User, Task
from datetime import datetime

def seed_dev_data():
    """Seed development database with test data."""
    session = next(get_session())

    # Create test user
    user = User(
        id="test-user-uuid",
        email="test@example.com",
        name="Test User",
        password_hash="<hashed>",
        created_at=datetime.utcnow()
    )
    session.add(user)

    # Create test tasks
    tasks = [
        Task(user_id=user.id, title="Buy groceries", description="Milk, eggs", completed=False),
        Task(user_id=user.id, title="Finish homework", completed=True),
    ]
    session.add_all(tasks)
    session.commit()
```

## Type Safety Guarantees

### Backend → Frontend Contract

- **Pydantic schemas** define exact JSON structure returned by API
- **TypeScript interfaces** match Pydantic schemas field-for-field
- **OpenAPI docs** (auto-generated by FastAPI) document API contracts
- **Runtime validation**: Pydantic validates incoming requests, rejects invalid data

### Database → Backend Contract

- **SQLModel** provides type-safe ORM with Pydantic validation
- **Type hints** on all model fields enforce correctness at development time
- **Database constraints** (NOT NULL, UNIQUE, FK) enforce correctness at runtime

### Frontend Type Safety

- **TypeScript strict mode** catches type errors at compile time
- **API client types** use interfaces from `lib/types.ts`
- **Component props** typed with TypeScript interfaces

## Summary

**Data Model Status**: ✅ COMPLETE

- ✅ Database schema defined with proper constraints and indexes
- ✅ SQLModel ORM models created for User and Task
- ✅ Pydantic schemas created for API request/response validation
- ✅ TypeScript interfaces defined matching backend schemas
- ✅ Validation rules documented for both frontend and backend
- ✅ Indexing strategy optimized for user isolation queries
- ✅ Migration strategy defined (create_all for Phase II)
- ✅ Type safety guaranteed across full stack

**Next Steps**:
1. → Create API contracts in `contracts/` directory
2. → Create `quickstart.md` with setup instructions
3. → Run `/sp.tasks` to generate implementation tasks

---

**Last Updated**: 2025-12-30
